\documentclass[12pt]{report}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[italian]{babel}
\usepackage{bytefield}
\usepackage{cancel}
\usepackage{caption}
% \usepackage{embedall}\embedfile{\jobname.tex}
\usepackage{float}
\usepackage[bookmarks]{hyperref}
\usepackage{listings}
\usepackage[scr=rsfs]{mathalpha}
\usepackage{siunitx}
\usepackage{subcaption}
\usepackage{tabularray}
\usepackage[most]{tcolorbox}
\usepackage{tikz}\usetikzlibrary{automata, chains, scopes, decorations.text, patterns, decorations.pathmorphing, positioning, decorations.pathreplacing, calligraphy, math}
\usetikzlibrary{external}
\usepackage{todonotes}
\usepackage{xcolor}

\newtheorem{teorema}{Teorema}
\newtheorem{corollario}{Corollario}
\newtheorem{proposizione}{Proposizione}
\newtheorem{proprietà}{Proprietà}
\newtheorem{lemma}{Lemma}
\newtheorem{fatto}{Fatto}
\newtheorem{definizione}{Definizione}
\newtheorem{nota}{Nota}

\renewcommand\qedsymbol{$\blacksquare$}

% \usepackage{teolang}

\definecolor{codegray}{gray}{0.95}

\lstdefinestyle{mystyle}{
  numberstyle=\tiny,
  basicstyle=\footnotesize,
  breaklines=true,
  numbers=left,
  numbersep=5pt,
}
\lstset{style=mystyle}

\overfullrule=0.2cm

\tikzexternalize 
\tcbset{shield externalize}
\begin{document}
\tableofcontents
\newpage

\chapter{Intro}
Gli automi a pila sono automi che oltre ad avere un controllo a stati finiti hanno una memoria arbitrariamente grande, ma organizzata a pila; cioè una memoria a cui si può accedere solo all'elemento più in cima.
Questo modello è one-way sul nastro di input (la versione two-way è più potente).
Analizzeremo principalmente il modello nondeterministico, infatti come vedremo il modello deterministico è -- a differenza degli FSA -- meno potente di quello nondeterministico.

Un automa a pila è una tupla
$$ M = \langle Q, \Sigma, \Gamma, \delta, q_0, Z_0, F \rangle $$
\noindent dove
\begin{itemize}
	\item $\Gamma$ è l'alfabeto della pila o alfabeto di lavoro
	\item $\delta$ è la funzione di transizione
	\item $q_0 \in Q$ è lo stato iniziale dell'automa
	\item $Z_0 \in \Gamma$ è lo stato iniziale della pila
	\item $F$ è un insieme di stati finali
\end{itemize}
La funzione di transizione dipende da tre cose: dallo stato corrente, dal simbolo dell'input corrente e dal simbolo in cima alla 
$$ \delta : Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow \text{PF}(Q \times \Gamma^*) $$
Quindi la funzione di transizione cambia lo stato dell'automa e rimpiazza il simbolo in cima alla pila con una stringa di stati della pila.
\begin{nota}
	$\text{PF}(-)$ sta per le parti finite, infatti se utilizzassimo $2^{Q \times \Gamma^*}$ potremmo avere programmi infiniti, visto che $\Gamma^*$ è un insieme infinito.
\end{nota}
\begin{nota}
	$\Sigma \cup \{ \epsilon \}$ perché sono contemplate mosse in base allo stato dell'automa che modificano la pila senza leggere un simbolo in input.
\end{nota}
% fig 12.1
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[ SQUIGGLY/.style={->
			  		     , decorate
			                     , decoration={snake,amplitude=.4mm,segment length=2mm,post length=1mm}},
			   ]
 		\begin{scope}[local bounding box=wordScope, start chain=word, node distance=0pt]
    			\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
			\node [draw, minimum height=20pt, on chain=word] {$a$};
    			\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
 		\end{scope}

		\node[draw, minimum width=20pt, minimum height=20pt] (state) [below=of word-2]	{$q$};

		\begin{scope}[local bounding box=stackScope, start chain=stack going below, node distance=0pt]
			\node [draw, minimum width=20pt, on chain=stack] [right=of state, xshift=1cm] {$A$};
    			\node [draw, minimum width=20pt, minimum height=40pt, on chain=stack] {$\vdots$};
 		\end{scope}

		\node (a) [above=of stack-1, yshift=-1cm] {\tiny Pila};
		\node (b) [above=of word-2, yshift=-1cm] {\tiny Parola};
		\node (c) [below=of state, yshift=1cm] {\tiny Stato};

		\draw[SQUIGGLY] (state.north) to (word-2.south);
		\draw[SQUIGGLY] (state.east) to (stack-1.west);
	\end{tikzpicture}
	\caption{Rappresentazione delle varie parti di un PDA}
\end{figure}
\begin{nota}
	Per convenzione la stringa di stati viene messa sulla pila di destra a sinistra, quindi il simbolo più a sinistra sarà in cima alla pila.
\end{nota}
% Visto che sono ammesse $\epsilon$-mosse il modello di sopra potrebbe non esaurire tutte le possibilità.

\begin{tcolorbox}[breakable]
Supponiamo di essere nello stato 
\begin{center}
	\begin{tikzpicture}[ SQUIGGLY/.style={->
			  		     , decorate
			                     , decoration={snake,amplitude=.4mm,segment length=2mm,post length=1mm}},
			   ]
 		\begin{scope}[local bounding box=wordScope, start chain=word, node distance=0pt]
    			\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
    			\node [draw, minimum height=20pt, on chain=word] {$a$};
    			\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
 		\end{scope}

		\node[draw, minimum width=20pt, minimum height=20pt] (state) [below=of word-2]	{$q$};

		\begin{scope}[local bounding box=stackScope, start chain=stack going below, node distance=0pt]
			\node [draw, minimum width=20pt, on chain=stack] [right=of state, xshift=1cm] {$A$};
    			\node [draw, minimum width=20pt, minimum height=40pt, on chain=stack] {$\vdots$};
 		\end{scope}

		\draw[SQUIGGLY] (state.north) to (word-2.south);
		\draw[SQUIGGLY] (state.east) to (stack-1.west);
	\end{tikzpicture}
\end{center}
e che la funzione $\delta$ sia così definita
$$\delta(q, a, A) = \{(q_1, \epsilon), (q_2, BCC)\} $$
L'applicazione delle due alternative porterebbe l'automa nei seguenti stati
\begin{figure}[H]
	\centering
	\begin{subfigure}{0.4\textwidth}
		\centering
		\begin{tikzpicture}[ SQUIGGLY/.style={->
			, decorate
			, decoration={snake,amplitude=.4mm,segment length=2mm,post length=1mm}},
			]
			\begin{scope}[local bounding box=wordScope, start chain=word, node distance=0pt]
				\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
				\node [draw, minimum height=20pt, on chain=word] {$a$};
				\node [draw, minimum height=20pt, on chain=word] {$?$};
				\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
			\end{scope}

			\node[draw, minimum width=20pt, minimum height=20pt] (state) [below=of word-3]	{$q_1$};

			\begin{scope}[local bounding box=stackScope, start chain=stack going below, node distance=0pt]
				\node [draw, minimum width=20pt, minimum height=40pt, on chain=stack] [right=of state, xshift=1cm] {$\vdots$};
			\end{scope}

			\draw[SQUIGGLY] (state.north) to (word-3.south);
			\draw[SQUIGGLY] (state.east) to (stack-1.west);
		\end{tikzpicture}
		\caption{Lo stato per $(q_1, \epsilon)$}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\centering
		\begin{tikzpicture}[ SQUIGGLY/.style={->
			, decorate
			, decoration={snake,amplitude=.4mm,segment length=2mm,post length=1mm}},
			]
			\begin{scope}[local bounding box=wordScope, start chain=word, node distance=0pt]
				\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
				\node [draw, minimum height=20pt, on chain=word] {$a$};
				\node [draw, minimum height=20pt, on chain=word] {$?$};
				\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
			\end{scope}

			\node[draw, minimum width=20pt, minimum height=20pt] (state) [below=of word-3]	{$q_2$};

			\begin{scope}[local bounding box=stackScope, start chain=stack going below, node distance=0pt]
				\node [draw, minimum width=20pt, on chain=stack] [right=of state, xshift=1cm] {$B$};
				\node [draw, minimum width=20pt, on chain=stack] {$C$};
				\node [draw, minimum width=20pt, on chain=stack] {$C$};
				\node [draw, minimum width=20pt, minimum height=40pt, on chain=stack] {$\vdots$};
			\end{scope}

			\draw[SQUIGGLY] (state.north) to (word-3.south);
			\draw[SQUIGGLY] (state.east) to (stack-1.west);
		\end{tikzpicture}
		\caption{Lo stato per $(q_2, BCC)$}
	\end{subfigure}
\end{figure}
Inoltre potremmo anche avere $\epsilon$-mosse, ad esempio
$$ \delta(q, \epsilon, A) = \{(r, B)\} $$
\begin{center}
	\begin{tikzpicture}[ SQUIGGLY/.style={->
			  		     , decorate
			                     , decoration={snake,amplitude=.4mm,segment length=2mm,post length=1mm}},
			   ]
 		\begin{scope}[local bounding box=wordScope, start chain=word, node distance=0pt]
    			\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
    			\node [draw, minimum height=20pt, on chain=word] {$a$};
    			\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$\dots$};
 		\end{scope}

		\node[draw, minimum width=20pt, minimum height=20pt] (state) [below=of word-2]	{$r$};

		\begin{scope}[local bounding box=stackScope, start chain=stack going below, node distance=0pt]
			\node [draw, minimum width=20pt, on chain=stack] [right=of state, xshift=1cm] {$B$};
    			\node [draw, minimum width=20pt, minimum height=40pt, on chain=stack] {$\vdots$};
 		\end{scope}

		\draw[SQUIGGLY] (state.north) to (word-2.south);
		\draw[SQUIGGLY] (state.east) to (stack-1.west);
	\end{tikzpicture}
\end{center}
\end{tcolorbox}

\section{Definizioni}
Ci riferiremo agli automi a pila come PDA (Push Down Automaton) e assumeremo che siano sempre nondeterministici, a meno che diversamente specificato.

Chiameremo lo stato complessivo dell'automa a pila la sua \textbf{configurazione}, questa verrà rappresentata compattamente come una tripla dello stato, la porzione di input ancora da leggere da quello corrente, e il contenuto della pila.
Quindi 
% fig 12.3
\begin{center}
	\begin{tikzpicture}[ SQUIGGLY/.style={->
			  		     , decorate
			                     , decoration={snake,amplitude=.4mm,segment length=2mm,post length=1mm}},
			   ]
 		\begin{scope}[local bounding box=wordScope, start chain=word, node distance=0pt]
    			\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$x$};
			\node [draw, minimum height=20pt, on chain=word] {$a$};
    			\node [draw, minimum width=40pt, minimum height=20pt, on chain=word] {$y$};
 		\end{scope}

		\node[draw, minimum width=20pt, minimum height=20pt] (state) [below=of word-2]	{$q$};

		\begin{scope}[local bounding box=stackScope, start chain=stack going below, node distance=0pt]
			\node [draw, minimum width=20pt, on chain=stack] [right=of state, xshift=1cm] {$A$};
    			\node [draw, minimum width=20pt, minimum height=40pt, on chain=stack] {$\alpha$};
 		\end{scope}

		\node (a) [above=of stack-1, yshift=-1cm] {\tiny Pila};
		\node (b) [above=of word-2, yshift=-1cm] {\tiny Parola};
		\node (c) [below=of state, yshift=1cm] {\tiny Stato};

		\draw[SQUIGGLY] (state.north) to (word-2.south);
		\draw[SQUIGGLY] (state.east) to (stack-1.west);
	\end{tikzpicture}
\end{center}
è rappresentato dalla configurazione
$$ (q, ay, A\alpha) $$
con $q \in Q, a \in \Sigma \cup \{\epsilon\}, y \in \Sigma^*, A \in \Gamma, \alpha \in \Gamma^*$.

Una mossa, indica che da una configurazione $q$ posso passare ad un'altra $p$, scritto
$$ q \vdash p$$
Ad esempio sopra abbiamo che
\begin{align*}
	(q, ay, A\alpha) &\vdash (q_1, y, \alpha) \\
	(q, ay, A\alpha) &\vdash (q_2, y, BCC\alpha) \\
	(q, ay, A\alpha) &\vdash (r, ay, B\alpha)
\end{align*}
Più rigorosamente, sia $(q, ay, Z\alpha)$ la configurazione corrente, con $Z \in \Gamma$ e $M$ l'automa a pila, diciamo che
$$ (q, ay, Z\alpha) \underset{M}{\vdash} (p, y, \beta\alpha) $$
sse $(p, \beta) \in \delta(q, a, Z)$ dove $q, p \in Q$, $y \in \Sigma^*$, $a \in \Sigma \cup \{\epsilon\}$, $Z \in \Gamma$ e $\alpha, \beta \in \Gamma^*$.
Se l'automa è ovvio dal contensto possiamo ometterlo da $\underset{M}{\vdash}$ e scrivere solo $\vdash$.

Da una configurazione $C'$ arrivo ad una configurazione $C''$ in un certo numero di mosse -- scritto 
$$ C' \underset{M}{\overset{*}{\vdash}} C'' $$
sse esistono $C_0, \dots, C_k$ con $C_0 = C'$ e $C_k = C''$ e $\forall i \in 1, \dots, k \; C_{i - 1} \underset{M}{\vdash} C_i$.

La configurazione iniziale di un automa su input $w \in \Sigma^*$ è 
$$ (q_0, w, Z_0) $$

Per accettare possiamo dare alcune diverse definizioni di configurazione accettante:
\begin{itemize}
	\item una volta finito l'input mi trovo in uno stato $q \in F$ e la pila può essere una stringa qualunque, questa è detta \textit{accettazione per stati finali}, ed indichiamo il linguaggio accettato per stati finali dall'automa a pila $M$ come
		$$ L(M) = \{ w \in \Sigma^* \mid (q_0, w, Z_0) \overset{*}{\vdash} (q, \epsilon, \gamma), q \in F, \gamma \in \Gamma^* \} $$
		\begin{nota}
			Siccome sono accettate le $\epsilon$ mosse può esserci il caso in arriviamo alla fine dell'input con uno stato non finale, e si può fare una $\epsilon$-mossa ed arrivare ad uno stato finale.
		\end{nota}
	\item è ragionevole pensare che tutto quello che viene messo sulla pila debba anche essere tolto, questa è detta \textit{accettazione per pila vuota} per cui si deve arrivare alla fine dell'input ed aver svuotato l'intera pila, ingorando lo stato.
		Il linguaggio accettato per pila vuota dall'automa $M$ lo indichiamo come
		$$ N(M) = \{ w \in \Sigma^* \mid (q_0, w, Z_0) \overset{*}{\vdash} (q, \epsilon, \epsilon), q \in Q \} $$
		In questo caso ovviamente si può omettere $F$ dalla definizione dell'automa.
	\item si può pensare di richiedere entrambe le precedenti, come vedremo più avanti queste tre nozioni sono equivalenti (nel caso nondeterministico)
\end{itemize}
\begin{nota}
	Questa cosa la vedremo meglio, ma visto che la pila è la struttura fondamentale per la ricorsione, i linguaggi CF sono i linguaggi regolari a cui è stata aggiunta la ricorsione.
\end{nota}

\begin{tcolorbox}
	Definiamo il linguaggio
	$$ \mathcal{L} = \{ a^n b^n \mid n \geq 1 \} $$
	possiamo usare la pila per contare il numero di $a$.
	\begin{align*}
		\delta(q_0, a, Z_0) &= \{(q_0, A)\} \\
		\delta(q_0, a, A)   &= \{(q_0, AA) \} \\
		\delta(q_0, b, A)   &= \{ (q_1, \epsilon) \} \\
		\delta(q_1, b, A)   &= \{ (q_1, \epsilon) \} 
	\end{align*}
	E vale che data questa $\delta$
	$$ \mathcal{L} = N(M) $$
	Questo è un caso particolare di automa a pila in cui utilizziamo in simbolo solo (cioè $A$, oltre a $Z_0$) è detto \textit{automa a contatore}.

	Definiamo alternativamente
	\begin{align*}
		\delta(q_0, a, Z_0) &= \{(q_0, AZ_0)\} \\
		\delta(q_0, a, A)   &= \{(q_0, AA)\} \\
		\delta(q_0, b, A)   &= \{(q_1, \epsilon)\} \\
		\delta(q_1, b, A)   &= \{(q_1, \epsilon)\} \\
		\delta(q_1, \epsilon, Z_0) &= \{(q_F, \epsilon)\}
	\end{align*}
	con $F = \{q_F\}$, e vale che con questa $\delta$
	$$ \mathcal{L} = L(M) $$
\end{tcolorbox}

\begin{tcolorbox}[breakable]
	Vediamo ora il caso di sopra, ma in cui
	$$ \mathcal{L} = \{ a^n b^n \mid n \geq 0 \} $$
	possiamo usare la pila per contare il numero di $a$.
	\begin{align*}
		\delta(q_0, \epsilon, Z_0) &= \{(q_0, \epsilon)\} \\
		\delta(q_0, a, Z_0) &= \{(q_0, A)\} \\
		\delta(q_0, a, A)   &= \{(q_0, AA) \} \\
		\delta(q_0, b, A)   &= \{ (q_1, \epsilon) \} \\
		\delta(q_1, b, A)   &= \{ (q_1, \epsilon) \} 
	\end{align*}
	E vale che data questa $\delta$ in cui si può direttamente accettare dallo stato $q_0$
	$$ \mathcal{L} = N(M) $$
	L'introduzione della prima regola è problematica, perché con input non vuoto permette di svuotare la pila da $Z_0$, bloccando la continuazione dell'automa, quindi abbiamo introdotto il nondeterminismo tra le due regole $\delta(q_0, \epsilon, Z_0)$ e $\delta(q_0, a, Z_0)$.

	Definiamo similmente a sopra
	\begin{align*}
		\delta(q_0, \epsilon, Z_0) &= \{(q_F, \epsilon)\} \\
		\delta(q_0, a, Z_0) &= \{(q_0, AZ_0)\} \\
		\delta(q_0, a, A)   &= \{(q_0, AA)\} \\
		\delta(q_0, b, A)   &= \{(q_1, \epsilon)\} \\
		\delta(q_1, b, A)   &= \{(q_1, \epsilon)\} \\
		\delta(q_1, \epsilon, Z_0) &= \{(q_F, \epsilon)\}
	\end{align*}
	con $F = \{q_F\}$, e vale che con questa $\delta$
	$$ \mathcal{L} = L(M) $$
	sempre introducendo non determinismo.
	
	Questa versione, a differenza di quello di sopra per pila vuota, può anche essere fatta senza non determinismo infatti definiamo $q_I$ come nuovo stato iniziale che è anche finale, se la stringa è vuota possono direttamente accettare, mentre 
	$$ \delta(q_I, a, Z_0) = \{(q_0, AZ_0)\} $$
	ci riconduce all'automa di sopra.
\end{tcolorbox}
\begin{tcolorbox}
	Supponiamo invece di voler riconoscere
	$$ L = \{ w \in \{a, b\}^* \mid \#_a(w) = \#_b(w) \} $$
	bisogna contare sia le $a$ che le $b$: finché si incontrano $a$ si aggiungono alla pila, e appena si incontrano $b$ le si tolgono. 
	Se durante questa operazione si svuota la pila iniziamo a contare le $b$ e facciamo la operazione inversa.
	Queste due operazioni continuano ad alternarsi finché la stringa non è svuotato.
\end{tcolorbox}

Definiamo ora l'automa a pila deterministico.
Questo in ogni configurazione permette una singola scelta:
\begin{itemize}
	\item sono vietate configurazioni che ammettono una mossa e una $\epsilon$-mossa, quindi $\forall q \in Q, z \in \Gamma$ se $\delta(q, \epsilon, z) \neq \varnothing$ allora $\forall a \in \Sigma \delta(q, a, Z) = \varnothing$
	\item $\forall q \in Q, z \in \Gamma, a \in \Sigma \cup \{\epsilon\} \mid |\delta(q, a, Z)|\leq 1$, quindi per ogni tripletta $q, a, Z$ è ammessa al massimo una mossa.
\end{itemize}
A questo punto abbiamo definito quattro modelli: deterministico e nondeterministico che possono accettare per pila vuota o per stato finale.
Vedremo che il caso nondeterminismo in questo caso è più potente del caso deterministico, e che nel modello nondeterministico automi che possono accettare per pila vuota o per stato finale sono equivalenti.

\subsection{Equivalenza tra le due nozioni di accettazione nel modello nondeterministico}
\subsubsection{Da stati finali a pila vuota}
Dato un automa $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$ e supponiamo che $L = L(M)$ sia il linguaggio accettato per stati finali.
Definiamo l'automa 
$$M' = (Q \cup \{q_0', q_e\}, \Sigma, \Gamma \cup \{X\}, \delta', q_0', X, \varnothing)$$
con $q_0', q_e \not \in Q$ e $X \not \in \Gamma$, vogliamo che $L= N(M')$.

Ad alto livello quando $M$ arriva in uno stato finale, $M'$ si sposta nello stato $q_e$ in cui inizia a svuotare la pila.
Infatti la $e$ di $q_e$ sta per ``empty''.

Definiamo ora $\delta'$:
\begin{enumerate}
	\item prima di tutto 
		$$ \delta'(q_0', \epsilon, X) = \{(q_0, Z_0X)\} $$
		questo serve solo ad infilare $X$ in fondo alla pila.
		La $X$ è necessaria per evitare che se l'automa iniziale $M$ svuota la pila si accetti la stringa.
	\item per ogni altra cosa $M'$ si può comportare come $M$:
		$$ \forall q \in Q, a \in \Sigma \cup \{\epsilon\}, z \in \Gamma \mid \delta(q, a, Z) \subseteq \delta'(q, a, Z) $$
	\item ogni qualvolta $M$ entra in uno stato finale $M'$ può -- enfasi su può -- iniziare a svuotare l'intera pila:
		$$ \forall q \in F, z \in \Gamma \cup \{X\} \mid (q_e, \epsilon) \in \delta'(q, \epsilon, Z) $$
	\item una volta entrato nello stato di svuotamento, continua a svuotare:
		$$ \forall z \in \Gamma \cup \{X\} \mid \delta'(q_e, \epsilon, Z) = \{(q_e, \epsilon)\}$$ 
\end{enumerate}

Questo necessariamente introduce nondeterminismo, infatti l'automa $M$ potrebbe entrare in uno stato finale prima di essere arrivato alla fine della stringa.
Ed anche se l'automa di partenza è deterministico il punto $3$ potrebbe in ogni caso introdurre nondeterminismo.

Supponiamo di avere un automa deterministico che accetta la stringa $w$ a pila vuota, allora ogni stringa che ha $w$ come prefisso non può essere accettata, perché il prefisso $w$ svuoterebbe la pila e un automa con pila vuota non può andare a avanti.
Quindi il nondeterminismo è in un certo senso necessario per automi a pila che accettano con pila vuota.

\subsubsection{Da pila vuota a stati finali}
Dato un automa $M = (Q, \Sigma, \Gamma,\delta, q_0, Z_0, \varnothing)$ che accetta per pila vuota il linguaggio $L = N(M)$, vogliamo creare un automa che accetti per stati finali.
Sia questo 
$$M' = (Q \cup \{q_0', q_F\}, \Sigma, \Gamma \cup \{X\}, \delta', q_0', X, F = \{q_F\})$$
con $q_0', q_F \not \in Q, X \not \in \Gamma$.

Definiamo ora $\delta'$:
\begin{itemize}
	\item come prima inizialmente infiliamo $X$ in fondo alla pila:
		$$ \delta'(q_0', \epsilon, X) = \{(q_0, Z_0X)\} $$
		$X$ serve a riconoscere quando la pila è vuota.
	\item a questo punto copiamo tutte le mosse di $M$, per cui
		$$ \forall q \in Q, a \in \Sigma \cup \{\epsilon\}, Z \in \Gamma \mid \delta'(q, a, Z) = \delta(q, a, Z) $$
	\item nel momento in cui $M$ svuota la prima, $M'$ si trova $X$ sulla pila, a questo punto può entrare in uno stato finale
		$$ \forall q \in Q \mid \delta'(q, \epsilon, X) = \{(q_F, \epsilon)\}$$
\end{itemize}
Supponendo che $M$ sia deterministico, $M'$ rimane deterministico -- la trasformazione preserva il determinismo.

% lezione 13
\section{Grammatiche di tipo 2}
Una grammatica è formata da quattro elementi:
$$ G = \langle V, \Sigma, P, S \rangle $$
e nello specifico, in quelle di tipo 2 le produzioni hanno la forma
$$ A \rightarrow \alpha \hspace{1cm} A \in V, \alpha \in (V \cup \Sigma)^* $$

Una rappresentazione utile per le derivazioni di linguaggi CF sono gli alberi, ad esempio data $w \in L(G)$, allora $S \overset{*}{\Rightarrow} w$.
Questa derivazione io la possono rappresentare come un albero di derivazione, o albero di parsing, o ancora parse tree.
Questo è un albero 
\begin{itemize}
	\item con radice etichettata con il simbolo iniziale della grammatica
	\item le foglie da sinistra a destra sono $w$
	\item i nodi possono essere di tre tipi:
		\begin{itemize}
			\item variabili, per i nodi interni
			\item terminali, per le foglie
			\item $\epsilon$ la parola vuota, in casi speciali per le foglie
		\end{itemize}
\end{itemize}
Dato un nodo
\begin{center}
	\begin{tikzpicture}
		\node {$A$}
			child { node {$X_1$} }
			child { node {$X_2$} }
			child { node {$\dots$} }	% non disegno il nodo
			child { node {$X_k$} };
	\end{tikzpicture}
\end{center}
rappresenta l'applicazione della regola di produzione
$$ A \rightarrow X_1 X_2 \dots X_k \in P \hspace{1cm} A \in V, \forall i \in 1, \dots, k \mid X_i \in V \cup \Sigma $$
All'ultimo livello possiamo avere nodi
\begin{center}
	\begin{tikzpicture}
		\node {$A$}
		child { node {$\epsilon$} };
	\end{tikzpicture}
\end{center}
solo se $A \rightarrow \epsilon \in P$.

Abbiamo detto che gli automi a pila riconoscono linguaggi con ricorsione, dove questa nell'automa si esprime nella memoria a pila, nelle grammatiche si esprime nella struttura ad albero.
 
% \begin{tcolorbox}[breakable] 	% extra \else error with externalized tikzpicture
Definiamo la grammatica per le parentesi correttamente bilanciate
\begin{align*}
	S &\rightarrow \epsilon \\
	S &\rightarrow ( S ) \\
	S &\rightarrow S S
\end{align*}
prendiamo ora la stringa $w = (())()()$ e scriviamone la derivazione
\begin{figure}[H]
	\centering
	\begin{subfigure}{0.3\textwidth}
		\centering
		\begin{tikzpicture}[scale=0.45, every node/.style={transform shape}]
			\node {$S$}
				[sibling distance=4.5cm]
				child { node {$S$} 
					[sibling distance=3cm]
					child { node {$S$} 
						[sibling distance=1cm]
						child { node {$($} }
						child { node {$S$} 
							[sibling distance=1cm]
							child { node {$($} }
							child { node {$S$} 
								child { node {$\epsilon$} }
							}
							child { node {$)$} }
						}
						child { node {$)$} }
					}
					child { node {$S$}
						[sibling distance=1cm]
						child { node {$($} }
						child { node {$S$} 
							child { node {$\epsilon$} }
						}
						child { node {$)$} }
					}
				}
				child { node {$S$} 
					[sibling distance=1cm]
					child { node {$($} }
					child { node {$S$} 
						child { node {$\epsilon$} }
					}
					child { node {$)$} }
				};
		\end{tikzpicture}
		\begin{align*}
			S &\Rightarrow S S  \\
			&\Rightarrow S S S  \\
			&\Rightarrow ( S ) S S  \\
			&\Rightarrow ( S ) ( S ) S  \\
			&\Rightarrow ( S ) ( S ) ( S )  \\
			&\Rightarrow ( ( S ) ) ( S ) ( S )  \\
			&\Rightarrow ( ( S ) ) ( S ) ( )  \\
			&\Rightarrow ( ( S ) ) ( ) ( )  \\
			&\Rightarrow ( ( ) ) ( ) ( )  \\
		\end{align*}
	\end{subfigure}
	\begin{subfigure}{0.3\textwidth}
		\centering
		\begin{tikzpicture}[scale=0.45, every node/.style={transform shape}]
 			\node {$S$}
			[sibling distance=4.5cm]
 			child { node {$S$} 
				[sibling distance=1cm]
 				child { node {$($} }
 				child { node {$S$} 
					[sibling distance=1cm]
 					child { node {$($} }
 					child { node {$S$} 
 						child { node {$\epsilon$} }
 					}
 					child { node {$)$} }
 				}
 				child { node {$)$} }
 			}
 			child { node {$S$} 
				[sibling distance=3cm]
 				child { node {$S$} 
					[sibling distance=1cm]
 					child { node {$($} }
 					child { node {$S$} 
 						child { node {$\epsilon$} }
 					}
 					child { node {$)$} }
 				}
 				child { node {$S$}
					[sibling distance=1cm]
 					child { node {$($} }
 					child { node {$S$} 
 						child { node {$\epsilon$} }
 					}
 					child { node {$)$} }
 				}
 			};
 		\end{tikzpicture}
		\begin{align*}
			S &\Rightarrow S S  \\
			  &\Rightarrow ( S ) S  \\
			  &\Rightarrow ( ( S ) ) S  \\
			  &\Rightarrow ( ( ) ) S  \\
			  &\Rightarrow ( ( ) ) S S  \\
			  &\Rightarrow ( ( ) ) ( S ) S  \\
			  &\Rightarrow ( ( ) ) ( ) S  \\
			  &\Rightarrow ( ( ) ) ( ) ( S )  \\
			  &\Rightarrow ( ( ) ) ( ) ( )  \\
		\end{align*}
	\end{subfigure}
	\begin{subfigure}{0.3\textwidth}
		\centering
		\begin{tikzpicture}[scale=0.45, every node/.style={transform shape}]
			\node {$S$}
				[sibling distance=4.5cm]
				child { node {$S$} 
					[sibling distance=3cm]
					child { node {$S$} 
						[sibling distance=1cm]
						child { node {$($} }
						child { node {$S$} 
							[sibling distance=1cm]
							child { node {$($} }
							child { node {$S$} 
								child { node {$\epsilon$} }
							}
							child { node {$)$} }
						}
						child { node {$)$} }
					}
					child { node {$S$}
						[sibling distance=1cm]
						child { node {$($} }
						child { node {$S$} 
							child { node {$\epsilon$} }
						}
						child { node {$)$} }
					}
				}
				child { node {$S$} 
					[sibling distance=1cm]
					child { node {$($} }
					child { node {$S$} 
						child { node {$\epsilon$} }
					}
					child { node {$)$} }
				};
		\end{tikzpicture}
	 	\begin{align*}
	 		S &\Rightarrow S S \\
	 		  &\Rightarrow S S S \\
	 		  &\Rightarrow ( S ) S S \\
	 		  &\Rightarrow ( ( S ) ) S S \\
	 		  &\Rightarrow ( ( ) ) S S \\
	 		  &\Rightarrow ( ( ) ) ( S ) S \\
	 		  &\Rightarrow ( ( ) ) ( ) S \\
	 		  &\Rightarrow ( ( ) ) ( ) ( S ) \\
	 		  &\Rightarrow ( ( ) ) ( ) ( ) \\
	 	\end{align*}
	\end{subfigure}
	\caption{Tre derivazioni diverse per la stringa $(())()()$ e gli alberi corrispondenti}
\end{figure}
Possiamo vedere che una stessa stringa ammette diverse derivazioni, ma non tutte queste portano allo stesso albero.
Infatti la prima e la terza derivazione utilizzano le stesse sostituzioni, solo in ordine diverso, e quindi generano alberi uguali; mentre nel secondo albero applichiamo derivazioni diverse.
Nella prima e nella terza derivazione abbiamo una struttura
\begin{center}
	\begin{tikzpicture}
		\node {$S$}
		child { node {$S$} 
			child { node {$\Delta$} }
			child { node {$\Delta$} }
		}
		child { node {$\Delta$} };
	\end{tikzpicture}
\end{center}
mentre la seconda ha una struttura
\begin{center}
	\begin{tikzpicture}
		\node {$S$}
		child { node {$\Delta$} }
		child { node {$S$} 
			child { node {$\Delta$} }
			child { node {$\Delta$} }
		};
	\end{tikzpicture}
\end{center}
% \end{tcolorbox}

Per evitare derivazioni multiple si utilizza un criterio detto di \textit{derivazione leftmost}: una derivazione è lefmost se ogni volta che si fa una sostituzione sostituisco sempre la variabile più a sinistra della forma sentenziale.
\begin{proposizione}
	Esiste una corrispondenza uno a uno tra derivazioni leftmost e alberi di derivazione.
\end{proposizione}
La seconda e la terza derivazioni dell'esempio di sopra sono due derivazioni leftmost diverse.

Diciamo che una grammatica è \textit{ambigua} se c'è una stringa che ammette almeno due alberi di derivazione -- o derivazioni leftmost -- diversi.

Nell'esempio di sopra si può vedere anche che ogni sottoalbero è una sequenza bilanciate di parentesi.

\begin{tcolorbox} % [breakable] 	% stesso problema di sopra
Se nella grammatica di sopra vorremmo anche le quadre, senza precedenze, questa è facilmente
\begin{align*}
 	S &\rightarrow \epsilon \\
 	S &\rightarrow ( S ) \\
 	S &\rightarrow [ S ] \\
 	S &\rightarrow S S
\end{align*}
Ma se si chiede che le quadre non possano stare all'interno delle tonde, diventa necessario suddividere le variabili in due livelli
\begin{align*}
 	S &\rightarrow T \\
 	S &\rightarrow [ S ] \\
 	S &\rightarrow S S \\
 	T &\rightarrow \epsilon \\
 	T &\rightarrow ( T ) \\
 	T &\rightarrow T T \\
\end{align*}
e vediamo un albero di derivazione di esempio
\begin{center}
	\begin{tikzpicture}
		\node {$S$}
		[sibling distance=1cm, level distance=1cm]
		child { node {$[$} }
		child { node {$S$} 
			[sibling distance=3cm]
			child { node {$S$} 
				[sibling distance=1cm]
				child { node {$T$} 
					child { node {$($} }
					child { node {$T$} 
						child { node {$\epsilon$} }
					}
					child { node {$)$} }
				}
			}
			child { node {$S$} 
				[sibling distance=1cm]
				child { node {$[$} }
				child { node {$S$} 
					child { node {$T$}
						child { node {$\epsilon$} }
					}
				}
				child { node {$]$} }
			}
		}
		child { node {$]$} };
	\end{tikzpicture}
\end{center}
\end{tcolorbox}


\section{Equivalenza tra grammatiche di tipo 2 ad automi a pila}
\subsection{Da una grammatica che genera un linguaggio generiamo un automa che riconosce lo stesso}
Data una grammatica
$$ G = \langle V, \Sigma, P, S \rangle $$
di tipo 2, vogliamo costruire
$$ M = \langle Q, \Sigma, \Gamma, \delta, q, Z_0, \varnothing \rangle $$
che accetta per pila vuota, con
\begin{itemize}
 	\item $Q$ formato da un solo stato $\{q\}$
 	\item $\Gamma = \Sigma \cup V$
 	\item $Z_0 = S$
\end{itemize}
e $\delta$ definito come
\begin{itemize}
 	\item se $A \rightarrow \alpha \in P$ allora $(q, \alpha) \in \delta(q, \epsilon, A)$
 	\item $\forall \sigma \in \Sigma$, $\delta(q, \sigma, \sigma) = \{ (q, \epsilon) \}$, cioè si consuma il simbolo in cima alla pila
\end{itemize}
 
Si può dimostrare che il linguaggio generato dalla grammatica $L(G)$ è uguale al linguaggio accettato dall'automa per pila vuota $N(M)$.

\begin{tcolorbox}[breakable]
 	Prendiamo
 	$$ G = \langle \{S, T, U\}, \{a, b\}, P, S \rangle $$
 	con $P$ definito
 	\begin{align*}
 		S &\rightarrow TU  \\
 		T &\rightarrow a T b \mid \epsilon \\
 		U &\rightarrow b U a \mid \epsilon \\
 	\end{align*}
 	questo genera
 	$$ L = \{ a^n b^{n + m} a^m \mid n \geq 0, m \geq 0 \} $$
 
 	Scriviamo le transizioni dell'automa corrispondente
 	$$ M = \langle \{q\}, \{a, b\}, \{S, T, U, a, b\}, \delta, q, S, \varnothing \rangle $$
 	con $\delta$ definito come
 	\begin{align*}
 		\delta(q, \epsilon, S) &= \{(q, TU)\} \\
 		\delta(q, \epsilon, T) &= \{(q, a T b), (q, \epsilon) \} \\
 		\delta(q, \epsilon, U) &= \{(q, b U a), (q, \epsilon) \} \\
 		\delta(q, a, a) &= \{(q, \epsilon)\} \\
 		\delta(q, b, b) &= \{(q, \epsilon)\} \\
 	\end{align*}
 	\newpage
 	Prendendo per esempio $w = abbbaa$, vediamo come viene accettata nondeterministicamente
 	\begin{align*}
 		(q, abbbaa, S) &\vdash (q, abbbaa, TU) \\
 		               &\vdash (q, abbbaa, TU) \\
 		               &\vdash (q, abbbaa, aTbU) \\
 		               &\vdash (q, bbbaa, TbU) \\
 		               &\vdash (q, bbbaa, bU) \\
 		               &\vdash (q, bbaa, U) \\
 		               &\vdash (q, bbaa, bUa) \\
 		               &\vdash (q, baa, Ua) \\
		               &\vdash (q, baa, bUaa) \\
 		               &\vdash (q, aa, Uaa) \\
 		               &\vdash (q, aa, aa) \\
 		               &\vdash (q, a, a) \\
 		               &\vdash (q, \epsilon, \epsilon) \\
 	\end{align*}
 	Leggere la i terminali consumati fino a un certo punto e il contentuto della pila in quel punto restituisce la forma sentenziale durante la derivazione.
 	Questo corrisponde a
 	\begin{align*}
 		S &\Rightarrow T U \\
 		  &\Rightarrow a T b U \\
 		  &\Rightarrow a b U \\
 		  &\Rightarrow a b b U a \\
 		  &\Rightarrow a b b b U a a \\
 		  &\Rightarrow a b b b a a \\
 	\end{align*}
\end{tcolorbox}
L'automa a pila tenta di simulare il processo di derivazione leftmost della stringa.

\subsection{Da un automa a pila costruiamo una grammatica di tipo 2}
% iniziamo a introdurla
Per la dimostrazione useremo una variazione degli automi a pila che non ne cambia la potenza computazionale.
In questa forma normale
\begin{itemize}
	\item all'inizio la pila contiene un simbolo speciale $Z_0$ che viene mai rimosso e non viene mai aggiunto
 		% lez 13.1
		\begin{center}
			\begin{tikzpicture}[ SQUIGGLY/.style={->
				, decorate
				, decoration={snake,amplitude=.4mm,segment length=2mm,post length=1mm}},
				]
				\begin{scope}[local bounding box=wordScope, start chain=word, node distance=0pt]
					\node [draw, minimum width=25pt, minimum height=25pt, on chain=word] {$\sigma$};
					\node [draw, minimum width=65pt, minimum height=25pt, on chain=word] {$\dots$};
				\end{scope}

				\node[draw, minimum width=25pt, minimum height=25pt] (state) [below=of word-1] {$q_0$};
				\node[draw, minimum width=25pt, minimum height=25pt] (stack) [right=of state] {$Z_0$};

				\draw[SQUIGGLY] (state.north) to (word-1.south);
				\draw[SQUIGGLY] (state.east) to (stack.west);
			\end{tikzpicture}
		\end{center}
 	\item alla fine l'input è stato letto completamente, la pila contiene solo $Z_0$ e lo stato è finale.
 		% lez 13.2
		\begin{center}
			\begin{tikzpicture}[ SQUIGGLY/.style={->
				, decorate
				, decoration={snake,amplitude=.4mm,segment length=2mm,post length=1mm}},
				]
				\begin{scope}[local bounding box=wordScope, start chain=word, node distance=0pt]
					\node [draw, minimum width=65pt, minimum height=25pt, on chain=word] {$\dots$};
					\node [minimum width=25pt, minimum height=25pt, on chain=word] {};
				\end{scope}

				\node[draw, minimum width=25pt, minimum height=25pt] (state) [below=of word-2] {$q_F$};
				\node[draw, minimum width=25pt, minimum height=25pt] (stack) [right=of state] {$Z_0$};

				\draw[SQUIGGLY] (state.north) to (word-2.south);
				\draw[SQUIGGLY] (state.east) to (stack.west);
			\end{tikzpicture}
		\end{center}
 	\item le mosse sulla pila possono essere solo
 		\begin{itemize}
 			\item push di un simbolo
 			\item pop di un simbolo
		 	\item pila invariata
 		\end{itemize}
 		quindi il pop non è più implicito
 	\item se una mossa legge un simbolo da input, allora non modifica la pila. 
 		Cioè le mosse che manipolano la pila sono seperate da quelle che manipolano l'input.
\end{itemize}
In questa forma
$$ \delta : Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow 2^{Q \times \{-, \text{pop}, a \in \Gamma \mid \text{push}(A)\}} $$
ed abbiamo che le mosse possono avere le seguenti forme
\begin{itemize}
 	\item mosse di lettura: $ (p, -) \in \delta(q, a, A) \hspace{1cm} a \in \Sigma \cup \{\epsilon\} $
 	\item pop: $(p, \text{pop}) \in \delta(q, \epsilon , A) $
 	\item push: $(p, \text{push}(B)) \in \delta(q, \epsilon , A) $
 	\item mosse che lasciano la pila invariata: $(p, -) \in \delta(q, \epsilon , A) $
\end{itemize}
 
\begin{tcolorbox}
 	Ad esempio se avessimo una sequenza di parentesi $([()]())$, la pila contiene inizialmente $Z_0$
	\begin{center}
		\begin{tikzpicture}[ SQUIGGLY/.style={->
			, decorate
			, decoration={snake,amplitude=.4mm,segment length=2mm,post length=1mm}},
			]
			\begin{scope}[local bounding box=col1, start chain=col1 going above, node distance=0pt]
				\node [minimum width=25pt, minimum height=25pt, on chain=col1] {$Z_0$};
			\end{scope}
			\begin{scope}[local bounding box=col2, start chain=col2 going above, node distance=0pt]
				\node [minimum width=25pt, minimum height=25pt, on chain=col2] [right=of col1-1]{$Z_0$};
				\node [minimum width=25pt, minimum height=25pt, on chain=col2] {$($};
			\end{scope}
			\begin{scope}[local bounding box=col3, start chain=col3 going above, node distance=0pt]
				\node [minimum width=25pt, minimum height=25pt, on chain=col3] [right=of col2-1]{$Z_0$};
				\node [minimum width=25pt, minimum height=25pt, on chain=col3] {$($};
				\node [minimum width=25pt, minimum height=25pt, on chain=col3] {$[$};
			\end{scope}
			\begin{scope}[local bounding box=col4, start chain=col4 going above, node distance=0pt]
				\node [minimum width=25pt, minimum height=25pt, on chain=col4] [right=of col3-1]{$Z_0$};
				\node [minimum width=25pt, minimum height=25pt, on chain=col4] {$($};
				\node [minimum width=25pt, minimum height=25pt, on chain=col4] {$[$};
				\node [minimum width=25pt, minimum height=25pt, on chain=col4] {$($};
			\end{scope}
			\begin{scope}[local bounding box=col5, start chain=col5 going above, node distance=0pt]
				\node [minimum width=25pt, minimum height=25pt, on chain=col5] [right=of col4-1]{$Z_0$};
				\node [minimum width=25pt, minimum height=25pt, on chain=col5] {$($};
				\node [minimum width=25pt, minimum height=25pt, on chain=col5] {$[$};
			\end{scope}
			\begin{scope}[local bounding box=col6, start chain=col6 going above, node distance=0pt]
				\node [minimum width=25pt, minimum height=25pt, on chain=col6] [right=of col5-1]{$Z_0$};
				\node [minimum width=25pt, minimum height=25pt, on chain=col6] {$($};
			\end{scope}
			\begin{scope}[local bounding box=col7, start chain=col7 going above, node distance=0pt]
				\node [minimum width=25pt, minimum height=25pt, on chain=col7] [right=of col6-1]{$Z_0$};
				\node [minimum width=25pt, minimum height=25pt, on chain=col7] {$($};
				\node [minimum width=25pt, minimum height=25pt, on chain=col7] {$($};
			\end{scope}
			\begin{scope}[local bounding box=col8, start chain=col8 going above, node distance=0pt]
				\node [minimum width=25pt, minimum height=25pt, on chain=col8] [right=of col7-1]{$Z_0$};
				\node [minimum width=25pt, minimum height=25pt, on chain=col8] {$($};
			\end{scope}
			\begin{scope}[local bounding box=col9, start chain=col9 going above, node distance=0pt]
				\node [minimum width=25pt, minimum height=25pt, on chain=col9] [right=of col8-1]{$Z_0$};
			\end{scope}

			% \node [below=of col2-1] {$($};
			% \node [below=of col3-1] {$[$};
			% \node [below=of col4-1] {$($};
			% \node [below=of col5-1] {$)$};
			% \node [below=of col6-1] {$]$};
			% \node [below=of col7-1] {$($};
			% \node [below=of col8-1] {$)$};
			% \node [below=of col9-1] {$)$};

			\node [left=of col1-1, xshift=1cm, yshift=2.5cm] {\rotatebox[origin=c]{90}{\tiny Pila}};
			\node [below=of col9-1, yshift=1cm] {\tiny Input};

			\draw[->] ([xshift=-0.45cm] col1-1.south) -- ([xshift=8cm] col1-1.south);
			\draw[->] ([yshift=-0.45cm] col1-1.west) -- ([yshift=3cm] col1-1.west);
			\draw[dashed] ([xshift=-2.75cm] col4-2.south) -- ([xshift=4.5cm] col4-2.south) node[xshift=0.5cm] {\tiny $([()]())$};
			\draw[dashed] ([xshift=-2.75cm] col4-3.south) -- ([xshift=4.5cm] col4-3.south) node[xshift=0.5cm] {\tiny $[()], ()$};
			\draw[dashed] ([xshift=-2.75cm] col4-4.south) -- ([xshift=4.5cm] col4-4.south) node[xshift=0.5cm] {\tiny $()$};

		\end{tikzpicture}
	\end{center}
 	questo disegno mostra la natura ricorsiva degli automi.
	Infatti visto che la pila di questo automa non può mai scendere sotto il suo livello iniziale, tutte le evoluzioni definite dalle linee tratteggiate definiscono parole valide del linguaggio.
\end{tcolorbox}
 
\begin{nota}
	Gli automi che abbiamo visto fino ad ora possono essere simulati da questa versione normalizzata, scomponendo una mossa una pop ed una serie di push utilizzando degli stati ausiliari.
\end{nota}

% lezione 14
Ripetiamo la versione di automa a pila semplificato vista a lezione scorsa, in questo per riuscire ad accettare dobbiamo arrivare in uno stato finale con solo $Z_0$ lo stato finale sulla pila.

Dobbiamo trovare un modo di trasformare un automa a pila come definito nella lezione scorsa, in una grammatica.
Questa grammatica ha nonterminali della forma $[qAp]$ con $q, p \in Q$ e $A \in V$, e rappresenta:
\begin{itemize}
	\item $q$ è lo stato in cui si inizia
	\item $p$ è lo stato in cui si finisce 
	\item e $A$ è il simbolo in cima alla pila all'inizio e alla fine della computazione.
\end{itemize}
% fig 14.1
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\draw[->] (0, 0) -- (0, 4) node[left, yshift=-0.2cm] {\rotatebox{90}{\tiny pila}};
		\draw[->] (0, 0) -- (5, 0) node[below, xshift=-0.2cm] {\tiny input};

		\node[label=left:{\tiny $q, A$}] at (1, 1) [circle,fill,inner sep=1.5pt] (a) {};
		\node[label=right:{\tiny $p, A$}] at (4, 1) [circle,fill,inner sep=1.5pt] (b) {};

		\tikzmath {
			real \x, \rand, \precx, \precy;
			\precx = 1;
			\precy = 1;
			for \x in {1.2,1.4,...,3.8} {
				\rand = 1 + (random(0, 100) / 66);
				{ \draw[-] (\precx, \precy) -- (\x, \rand); };
				\precx = \x;
				\precy = \rand;
			};
			{ \draw[-] (\precx, \precy) -- (4, 1); };
		}
		\draw[dashed] (1, 1) -- (1, 0);
		\draw[dashed] (4, 1) -- (4, 0);
		\draw[dashed] (1, 1) -- (4, 1);
		\draw[decorate, decoration={brace, mirror, amplitude=0.2cm}] (1, 0) to node[below, yshift=-0.2cm] {\tiny $w$} (4, 0);
	\end{tikzpicture}
	\caption{La computazione rappresentata dal simbolo $[qAp]$}
\end{figure}
Infatti negli automi come li abbiamo definiti, vale la proprietà per cui ??? % Z_0

Definiamo ora le regole di produzione della grammatica induttivamente come le stringhe riconosciute dalla computazione $[qAp]$:
\begin{itemize}
	\item base: abbiamo due casi
		\begin{itemize}
			\item caso $0$: il caso più semplice è $[qAq]$, qui l'unica parola riconosciuta è $\epsilon$, quindi è necessaria la regola
				$$ [qAq] \rightarrow \epsilon $$
				Quindi creo tutte le produzioni della forma
				$$ \forall q \in Q, A \in \Gamma \mid [qAq] \rightarrow \epsilon $$	% domanda pighi su computazione che inizia e finisce nello stato q
			\item caso $0'$: il secondo caso più semplice è quello in qui si è nello stato $q$, si consuma un carattere o nessuno, e questo ci porta nello stato $p$; cioè $(p, -) \in \delta(q, a, A)$ con $a \in \Sigma \cup \{\epsilon\}$.
				Questo si traduce nella produzione
				$$ [qAp] \rightarrow a, \hspace{1cm} a \in \Sigma \cup \{\epsilon\} $$
				Quindi creo tutte le produzioni della forma
				$$ \forall q, p \in Q, A \in \Gamma, a \in \Sigma \cup \{\epsilon\} \mid [qAp] \rightarrow a $$
		\end{itemize}
	\item passo: si distinguono due casi
		\begin{figure}[H]
			\centering
			\begin{subfigure}{0.45\textwidth}
				\centering
				\begin{tikzpicture}
					\draw[->] (0, 0) -- (0, 4) node[left, yshift=-0.2cm] {\rotatebox{90}{\tiny pila}};
					\draw[->] (0, 0) -- (5, 0) node[below, xshift=-0.2cm] {\tiny input};

					\node[label=left:{\tiny $q, A$}] at (1, 1) [circle,fill,inner sep=1.5pt] (a) {};
					\node[label=right:{\tiny $p, A$}] at (4, 1) [circle,fill,inner sep=1.5pt] (b) {};
					\node[label=below right:{\tiny $r, A$}] at (3, 1) [circle,fill,inner sep=1.5pt] (c) {};
			
					\tikzmath {
						real \x, \rand, \precx, \precy;
						\precx = 1;
						\precy = 1;
						for \x in {1.2,1.4,...,2.8} {
							\rand = 1.2 + (random(0, 100) / 80);
							{ \draw[-] (\precx, \precy) -- (\x, \rand); };
							\precx = \x;
							\precy = \rand;
						};
						{ \draw[-] (\precx, \precy) -- (3, 1); };
						\precx = 3;
						\precy = 1;
						for \x in {3.2,3.4,...,3.8} {
							\rand = 1.2 + (random(0, 100) / 80);
							{ \draw[-] (\precx, \precy) -- (\x, \rand); };
							\precx = \x;
							\precy = \rand;
						};
						{ \draw[-] (\precx, \precy) -- (4, 1); };
					}
					\draw[dashed] (1, 1) -- (1, 0);
					\draw[dashed] (3, 1) -- (3, 0);
					\draw[dashed] (4, 1) -- (4, 0);
					\draw[dashed] (1, 1) -- (4, 1);
					\draw[decorate, decoration={brace, mirror, amplitude=0.2cm}] (1, 0) to node[below, yshift=-0.1cm] {\tiny $w'$} (3, 0);
					\draw[decorate, decoration={brace, mirror, amplitude=0.2cm}] (3, 0) to node[below, yshift=-0.1cm] {\tiny $w''$} (4, 0);
					\draw[decorate, decoration={brace, mirror, amplitude=0.2cm}] (1, -0.5) to node[below, yshift=-0.1cm] {\tiny $w$} (4, -0.5);
				\end{tikzpicture}
			\end{subfigure}
			\begin{subfigure}{0.45\textwidth}
				\centering
				\begin{tikzpicture}
					\draw[->] (0, 0) -- (0, 4) node[left, yshift=-0.2cm] {\rotatebox{90}{\tiny pila}};
					\draw[->] (0, 0) -- (5, 0) node[below, xshift=-0.2cm] {\tiny input};

					\node[label=left:{\tiny $q, A$}] at (1, 1) [circle,fill,inner sep=1.5pt] (a) {};
					\node[label=left:{\tiny $q', B$}] at (1.1, 1.4) [circle,fill,inner sep=1.5pt] (b) {};
					\node[label=right:{\tiny $p', B$}] at (3.9, 1.4) [circle,fill,inner sep=1.5pt] (c) {};
					\node[label=right:{\tiny $p, A$}] at (4, 1) [circle,fill,inner sep=1.5pt] (d) {};

					\draw[-] (a) -- (b);
					\draw[-] (c) -- (d);
			
					\tikzmath {
						real \x, \rand, \precx, \precy;
						\precx = 1.1;
						\precy = 1.4;
						for \x in {1.2,1.4,...,3.6} {
							\rand = 1.5 + (random(0, 100) / 80);
							{ \draw[-] (\precx, \precy) -- (\x, \rand); };
							\precx = \x;
							\precy = \rand;
						};
						{ \draw[-] (\precx, \precy) -- (3.9, 1.4); };
					}
					\draw[dashed] (1, 1) -- (1, 0);
					\draw[dashed] (4, 1) -- (4, 0);
					\draw[dashed] (1, 1) -- (4, 1);
					\draw[dashed] (1.1, 1.4) -- (3.9, 1.4);
					\draw[decorate, decoration={brace, mirror, amplitude=0.2cm}] (1, 0) to node[below, yshift=-0.2cm] {\tiny $w$} (4, 0);
				\end{tikzpicture}
			\end{subfigure}
		\end{figure}
		% fig 14.2
		\begin{itemize}
			\item caso 1: nei passi intermedi (tranne l'ultimo) la pila è sempre strettamente più alta di quando si è iniziato, questo si traduce in
				$$ [qAp] \rightarrow [q'Bp'] $$
				con $(q', \text{push}(B)) \in \delta(q, \epsilon, A)$ e $(p, \text{pop}) \in \delta(p', \epsilon, B)$.
				Quindi 
				\begin{multline*}
				\forall q, q', p, p' \in Q, A, B \in \Gamma \\ \mid
					(q', \text{push}(B)) \in \delta(q, \epsilon, A) \wedge (p, \text{pop}) \in \delta(p', \epsilon, B) \\
					\Rightarrow [qAp] \rightarrow [q'Bp'] 
				\end{multline*}
			\item caso 2: la computazione $[qAp]$ svuota la pila fino alla $A$ inizia e poi continua, allora possiamo scomporre la computazione in due parti, quindi
				$$ \forall q, p, r \in Q, A \in \Gamma \mid [qAp] \rightarrow [qAr][rAp] $$
		\end{itemize}
\end{itemize}
Si può dimostrare che
\begin{lemma}
	$\forall q, p \in Q, A \in \Gamma, w \in \Sigma^* \mid [qAp] \overset{*}{\Rightarrow} w$ sse 
	% fig 14.3
	l'automa $M$ in una configurazione con $A$ in cima alla pila, stato $q$, dopo aver letto $w$ raggiunge una configurazione in cui il contentuto della pila è lo stesso dell'inizio, lo stato è $p$ e nei passi intermedi la pila non scende mai sotto il livello iniziale.
\end{lemma}
Quindi durante una computazione quello che c'è sotto al simbolo in cima alla pina all'inizio della computazione non è rilevante.

Per finire di costruire la grammatica manca di definire l'assioma.
Prima di tutto si può notare che visto che l'automa parte nello stato $q_0$ con $Z_0$ e basta sulla pila, una stringa $w$ può essere generata solo dalle triple 
$$[q_0Z_0q_F] \overset{*}{\Rightarrow} w$$
con $q_0$ iniziale e $q_F$ finale.
Quindi definiamo l'insieme dei nonterminali della grammatica $V$ come l'insieme di tutte le triple definite induttivamente sopra unito ad un nuovo nonterminale $S$ tale che
$$ \forall q_F \in F \mid S \rightarrow [q_0 Z_0 q_F] \in P $$
e questo $S$ così definito è il simbolo iniziale.

\section{Forme normali per le grammatiche di tipo 2}
Si può vedere che tutte le produzioni generate dalla traduzione da automa a pila a grammatica sono di pochi tipi: variabile a terminale, variabile a variabile e variabile a coppia di variabili.
Da questo fatto e dal fatto che i linguaggi riconosciuti dagli automi a pila sono esattamente quelli generati dalle grammatiche di tipo 2, ci rendiamo conto che possiamo restringere di molto il tipo di forma che il lato destro di una produzione di una grammatica CF può assumere.
Nel caso di sopra appunto da variabile a terminale, da variabile a variabile e da variabile a coppia di variabili.

Vediamo ora due forme normali.
Ogni grammatica può essere trasformata in una di queste forme normali a patto di sacrificare la parola vuota.

\subsection{Forma normale di Greibach}
In una grammatica in FNG (Forma Normale di Greibach) tutte le produzioi sono della forma
$$ A \rightarrow a B_1 \dots B_k, \hspace{1cm} a \in \Sigma, A, B_1, \dots, B_k \in V, k \geq 0 $$

Supponiamo di avere la gramamtica
\begin{align*}
	A &\rightarrow a B B \\
	A &\rightarrow b \\
	B &\rightarrow b B \\
	B &\rightarrow b
\end{align*}
e di aver fatto la trasformazione in automa a pila.
In questa forma normale la pila avrà in cima sempre un terminale e quindi si può avere un simbolo di lookahead e scegliere più precisamente la prossima produzione da utilizzare, anche se non si toglie il nondeterminismo (v. $B \rightarrow b B$ e $B \rightarrow b$).
Un altro vantaggio di avere sempre un terminale in cima alla pila è che in questo tipo di automa si possono eliminare le $\epsilon$-mosse.

\subsection{Forma normale di Chomsky}
Nella FNC (Forma Normale di Chomsky) ci sono solo due tipi di regole
\begin{align*}
	A & \rightarrow B C & A, B, C \in V \\
	A & \rightarrow a & A \in V, a \in \Sigma \\
\end{align*}
Questa genera alberi di derivazione binari, salvo sulle foglie; ed è comoda per studiare alcune proprietà combinatorie.

\subsubsection{Trasformazione in FNC}
Data una grammatica genererica $G$ eseguiamo i seguenti passi (l'ordine è importante) per trasformarla in FNC:
\begin{enumerate}
	\item eliminazione delle $\epsilon$-produzioni: diciamo che una variabile $A$ è \textit{cancellabile} sse $A \overset{*}{\Rightarrow} \epsilon$.
		Induttivamente $A$ è cancellabile se
		\begin{itemize}
			\item banalmente $A \rightarrow \epsilon$
			\item o se $A \rightarrow X_1 X_2 \dots X_k$ e $X_1, X_2, \dots, X_k$ sono tutti cancellabili.
		\end{itemize}
		Questo può essere definito come una chiusura dove
		$$ C_0 = \{ A \mid A \rightarrow \epsilon \} $$
		e 
		$$ C_i = C_{i - 1} \cup \{ A \mid \exists A \rightarrow X_1 X_2 \dots X_k \; \text{con} \; \forall i \in 1, \dots, k \mid X_i \in C_{i - 1} \} $$
		Visto che
		$$ C_0 \subseteq C_1 \subseteq \dots \subseteq V $$
		e $V$ è finito, allora esiste un $i$ tale che $C_i = C_{i - 1}$.

		Ora sia $C$ l'insisme delle variabili cancellabili, costruiamo una grammatica $G' = \langle V, \Sigma, P', S \rangle$ con $P'$ costituito da tutte le produzioni di $P$ eccetto le $\epsilon$ produzioni e per ogni produzione $A \rightarrow X_1 X_2 \dots X_k$ con $X_1, X_2, \dots, X_k \in V \cup \Sigma$ aggiungo a $P'$ le produzioni $A \rightarrow X_{i_1} X_{i_2} \dots X_{i_j}$ tali che $1 \leq i_1 < i_2 < \dots < i_j \leq k$ e per $\forall X_l \not \in X_{i_1}, \dots, X_{i_j} \mid X_l \in C$ e $j \geq 1$.

		\begin{tcolorbox}
			Supponiamo di avere nella gramamtica $G$ che vogliamo trasformare la produzione
			$$ A \rightarrow B C a D $$
			e che l'insieme delle variabili cancellabili è $C = \{C, D\}$.

			Nella mia gramamtica $G'$ simulo la cancellazione di $C$ e $D$ aggiungendo le produzioni
			\begin{align*}
				A &\rightarrow B a D \\
				A &\rightarrow B C a \\
				A &\rightarrow B a \\
			\end{align*}
		\end{tcolorbox}

		\begin{tcolorbox}
			Supponiamo di avere nella gramamtica $G$ che vogliamo trasformare la produzone
			$$ A \rightarrow C D E $$
			e che l'insieme delle variabili cancellabili è $C = \{C, D, E\}$.

			Nella mia gramamtica $G'$ simulo la cancellazione di $C$ e $D$, quindi aggiungo le produzioni
			\begin{align*}
				A &\rightarrow C D \\
				A &\rightarrow C E \\
				A &\rightarrow D E \\
				A &\rightarrow C \\
				A &\rightarrow D \\
				A &\rightarrow E \\
			\end{align*}
		\end{tcolorbox}

		Visto che le produzioni da aggiungere sotto tutti i sottoinsiemi delle variabili cancellabili di un lato destro meno l'insieme vuoto, vengono aggiunge nel caso peggiore un numero esponenziale di produzioni.
	\item eliminazione delle produzioni unitarie: una produzione unitaria è una produzione della forma
		$$ A \rightarrow B, \hspace{1cm} A, B \in V $$
		Costruiamo similmente a prima l'insieme di tutte le coppie di variabili $X, Y$ tali per cui $X \overset{+}{\Rightarrow} Y$, cioè per cui vale
		Abbiamo quindi
		$$ X \rightarrow A_1 \rightarrow \dots \rightarrow Y $$
		questo processo infatti le catene sono di lunghezza al più $|V|$ senza contenere cicli.

		Nella nuova grammatica tolgo tutte le produzioni unitarie e se $X \rightarrow \dots \rightarrow Y \rightarrow \alpha$ e $\alpha \in \Sigma$ oppure $|\alpha| > 1$, allora aggiungo la produzione $X \rightarrow \alpha$.
	\item eliminazione simboli inutili: $X \in V \cup \Sigma$ è utile sse $\exists S \overset{*}{\Rightarrow} \alpha X \beta \overset{*}{\Rightarrow} w \in \Sigma^*$.
		Questi sono eliminati utilizzando algoritmi sui grafi (chiusura bottom up, chiusura top down, non lo ha spiegato ma ci sono negli appunti del Santini).
	\item eliminazione dei terminali: in tutte le produzioni $A \rightarrow \alpha$ con $|\alpha| > 1$ si introducono nonterminali per ogni terminale.
		\begin{tcolorbox}
			Supponiamo di avere le produzioni
			\begin{align*}
				A &\rightarrow A aab C \\
				A &\rightarrow b C \\
				A &\rightarrow b b \\
			\end{align*}
			introduciamo i nonterminali $X_a$ e $X_b$ e le regole
			\begin{align*}
				A &\rightarrow A X_a X_a X_b C \\
				A &\rightarrow X_b C \\
				A &\rightarrow X_b X_b \\
				X_a & \rightarrow a \\
				X_b & \rightarrow b
			\end{align*}
		\end{tcolorbox}
	\item binarizzazione delle produzioni: per ogni produzione $A \rightarrow B_1 B_2 \dots B_k$ con $k > 2$, si introducono delle produzioni intermedie
		\begin{align*}
			A &\rightarrow B_1 Z_1 \\
			Z_1 &\rightarrow B_2 Z_2 \\
			    &\vdots \\
			Z_{k - 2} &\rightarrow B_{k - 1} B_k
		\end{align*}
\end{enumerate}
\begin{tcolorbox}[breakable]
	Date le produzioni
	\begin{align*}
		S &\rightarrow a B \\
		S &\rightarrow b A \\
		A &\rightarrow a \\
		A &\rightarrow a S \\
		A &\rightarrow b A A \\
		B &\rightarrow b \\
		B &\rightarrow b S \\
		B &\rightarrow a B B \\
	\end{align*}
	questa è già priva di $\epsilon$-produzioni, produzioni unitarie e tutti i simboli sono utili.

	Ora eliminiamo i terminali e otteniamo
	\begin{align*}
		S &\rightarrow X_a B \\
		S &\rightarrow X_b A \\
		A &\rightarrow a \\
		A &\rightarrow X_a S \\
		A &\rightarrow X_b A A \\
		B &\rightarrow b \\
		B &\rightarrow X_b S \\
		B &\rightarrow X_a B B \\
		X_a &\rightarrow a \\
		X_b &\rightarrow b \\
	\end{align*}
	ed ora binarizziamo le produzioni
	\begin{align*}
		S &\rightarrow X_a B \\
		S &\rightarrow X_b A \\
		A &\rightarrow a \\
		A &\rightarrow X_a S \\
		A &\rightarrow X_b E_1 \\
		E &\rightarrow A A \\
		B &\rightarrow b \\
		B &\rightarrow X_b S \\
		B &\rightarrow X_a E_2 \\
		E_2 &\rightarrow B B \\
		X_a &\rightarrow a \\
		X_b &\rightarrow b \\
	\end{align*}
\end{tcolorbox}

 
\end{document}
